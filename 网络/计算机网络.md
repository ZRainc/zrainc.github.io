**OSI七层体系结构**

物理层

数据链路层

网络层

传输层

会话层

表示层

应用层：





**TCP/IP体系结构**

网络接口层：

网络层：IP

运输层：TCP/UDP

应用层：各种应用层协议：Telnet\FTP\SMTP



**五层体系结构**

物理层：是实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

数据链路层：两台主机之间的数据传输，总是在⼀段⼀段的链路上传送的，这就需要使⽤专⻔的链路层的协议。帧

网络层：计算机网络进行通信的两个计算机之间可能会经过很多个数据链路，也可能要经过多个通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据即使传输。报文

传输层：负责向两台主机进程之间的通信提供通用的数据传输服务（TCP、UDP）

应用层：通过应用进程间的交互来完成特定的网络应用。DNS(域名解析)、HTTP、SMTP(邮件协议)



**三次握手、四次挥手**

![image-20210323133512391](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210323133512391.png)

客户端——发送带有SYN标志的数据包——一次握手——服务端

服务端——发送带有SYN/ACK标志的数据包——二次握手——客户端

客户端——发送带有ACK标志的数据包——三次握手——服务端

**三次握手**：建立可靠的通信通道

第一次握手：Client什么都不能确认，Server确认了对方发送正常，自己接收正常

第二次握手：Client确认了自己发送正常，接收正常，对方发送、接收正常；Server确认对方发送正常，自己接收正常

第三次握手：Client确认了自己发送正常，接收正常，对方发送、接收正常；Server确认自己发送、接收正常，对非发送、接收正常

**为什么要回传SYN**

接收端回传发送端传递过去的SYN，让发送端确认接收端接收到的信息就是发送端传递的信息

**传了SYN，为啥还要传ACK**

双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问

题，但是接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证

**四次挥手**

![image-20210323135630719](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210323135630719.png)

断开一个TCP连接需要四次挥手：

1、客户端——发送一个FIN，用来关闭客户端到服务端的数据传输

2、服务端——收到一个FIN，发送一个ACK，确认的序号为收到的序号加1，和SYN一样，一个FIN将占用一个序号

3、服务端——关闭与客户端的连接，发送一个FIN给客户端

4、客户端——发送ACK报文确认

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态，当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后就完全关闭了TCP连接。

举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B可能还会有要说的话，A 不能要求 B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。



TCP/UDP

![image-20210323143118646](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210323143118646.png)

TCP协议如何保证可靠传输

1、应用数据被切割成TCP认为合适发送的数据块

2、TCP给发送的每一个数据进行编号，接收端进行排序

3、校验和。TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。

4、TCP接收端会丢弃重复的数据

5、流量控制： TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防⽌包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量控制）

6、拥塞控制：当网络阻塞时，减少数据的发送

7、ARQ协议：也是为了实习可靠传输的，它的基本原理是每发完一个分组就停止发送，等待对方确认。在收到确认再发送下一组

8、超时重传：当TCP发送一个端后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能即使确认接收到一个报文，将重发这个报文段。



**ARQ协议**：

**⾃动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停⽌等待ARQ协议和连续ARQ协议。

**滑动窗⼝和流量控制**

TCP利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。接收⽅发送的确认报⽂中的窗⼝字段可以⽤来控制发送⽅窗⼝⼤⼩，从⽽影响发送⽅的发送速率。将窗⼝字段设置为 0，则发送⽅不能发送数据。

**在浏览器中输⼊url地址 ->> 显示主⻚的过程**

1. DNS解析

2. TCP连接

3. 发送HTTP请求

4. 服务器处理请求并返回HTTP报⽂

5. 浏览器解析渲染⻚⾯

6. 连接结束

**HTTP长连接和短连接**

在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客户端和服务端都⽀持⻓连接。

**HTTP是无状态的，如何保存用户状态**

HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。Session 机制的存在就是为了解决这个问题，Session 的主要作⽤就是通过服务端记录⽤户的状态。在服务端保存 Session 的⽅法很多，最常⽤的就是内存和数据库(⽐如是使⽤内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？⼤部分情况下，我们都是通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。

**Session和Cookie**

Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。

Cookie⼀般⽤来保存⽤户信息。Session的主要作⽤就是通过服务端记录⽤户的状态。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。

 **HTTP 1.0和HTTP 1.1的主要区别是什么**

长连接

状态码



**URI和URL**

URI：统一资源标识符。唯一标识一种资源。身份证

URL：统一资源定位符。提供该资源的路径。不仅唯⼀标识资源，⽽且还提供了定位该资源的信息。是一种具体的URI。家庭住址

**HTTP和HTTPS的区别**

1、端口。http默认端口80，https默认端口443

2、安全性和资源消耗：HTTP协议运行在TCP之上，所有传输的都是明文，客户端和服务端都无法验证对方身份。HTTPS运行是SSL/TLS之上的HTTP协议SSL/TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。

对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密算法有DES、AES等；

⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度᫾慢，典型的⾮对称加密算法有RSA、DSA等。

