1、两数之和

方法一：暴力

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] arr = new int[2];
        for(int i = 0; i < nums.length; i++) {
            for(int j = i+1 ; j < nums.length; j++) {
                if(nums[i] + nums[j] == target) {
                    arr[0]=i;
                    arr[1]=j;  
                }
            }
        }
        return arr;
    }
}
```

方法二：使用

2、数字反转

方法一：利用StringBuffer的reverse方法，有点傻

```java
public class Revers {
    public static int reverse(int x) {
        int res = 0;
        if(x>=0) {
            String s = String.valueOf(x);
            StringBuffer sb = new StringBuffer(s);
            StringBuffer ss = sb.reverse();
            for(int i = 0; i < ss.length(); i++){
                while (ss.charAt(i) == 0) {
                    ss.substring(1);
                }
            }
            System.out.println(ss);
            String s1 = new String(ss);
            res = Integer.valueOf(s1);
        } else {
            x = -x;
            String s2 = String.valueOf(x);
            StringBuffer sb2 = new StringBuffer(s2);
            StringBuffer ss2 = sb2.reverse();
            for(int i = 0; i < ss2.length(); i++){
                while (ss2.charAt(i) == 0) {
                    ss2.substring(1);
                }
            }
            System.out.println(ss2);
            String s3 = new String(ss2);
            res = Integer.valueOf(s3);
            res = -res;
        }
        System.out.println(res);
        return res;
    }
    public static void main(String[] args) {
        Revers.reverse(-1203000);
    }

}
```

方法二：利用数学方法

```java
class Solution {
    public int reverse(int x) {
        long n = 0;
        while (x != 0) {
            n = n*10 + x%10;
            x = x / 10;
        }
        return (int) n == n ? (int) n : 0;
    }
}
```

## 3、合并两个有序链表

方法一、递归

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }else if(l2 == null) {
            return l1;
        }else if(l1.val <= l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l2.next, l1);
            return l2;
        }
    }
}
```

方法二：迭代

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode preHead = new ListNode(-1);
        ListNode prev = preHead;
        while(l1 != null && l2 != null) {
            if(l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        prev.next = l1 == null ? l2 : l1;
        return preHead.next;
    }
}
```

## 链表反转

方法一：迭代

```java
class Solution {
    public ListNode reverseList(List head) {
        if(head == null) return null;
        ListNode pre = null;
        ListNode next ;
        while(head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```

方法二：递归

```java
class Solution {
    public ListNode reverseList(List head) {
    	ListNode newHead;
        if(head == null || head.next == null){
            return head;
        }
        newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

## 删除排序链表中的重复元素

方法一：迭代

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode temp = head;
        while (temp !=null && temp.next != null) {
            if(temp.val == temp.next.val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return head;
    }
}
```

方法二：递归

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head !=null && head.next != null && head.val == head.next.val) {
            while (head.val == head.next.val) {
                head.next = head;
            }
            return deleteDuplicates(head);
        } else {
            head.next = deleteDuplicates(head.next);
        }
        return head;    
    }
}
```

## 删除排序数组中重复的元素

方法一：暴力

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int count = 0;
        for(int i = 0 ; i < nums.length; i++) {
            for(int j = i+1; j < nums.length ; j++) {
                if(nums[i] == nums[j] ) {
                    for(int k = j; k < nums.length - 1 ; k++){
                        nums[k] = nums[k+1];
                        count++;
                    }
                }
            }
        }
        return nums.length-count;
    }
}
```

方法二：快慢指针，一个遍历，一个存储

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) return 0;
        int i = 0;
        for(int j = 1; j < nums.length; j++ ) {
            if(nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i+1;
    }
}
```

## 35、搜索插入位置

方法一：暴力

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums.length == 0) return 0;
        int j = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] < target) {
                j++; 
            }
        }
        return j;
    }
}
```

方法二：二分法

```

```

